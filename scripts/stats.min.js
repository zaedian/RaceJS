// stats.js - http://github.com/mrdoob/stats.js
// Enhancements to improve real-time performance monitoring and usability
(function (globalScope, statsModuleFactory) {
    // UMD (Universal Module Definition) pattern
    if (typeof exports === "object" && typeof module !== "undefined") {
        // CommonJS (e.g., Node.js)
        module.exports = statsModuleFactory();
    } else if (typeof define === "function" && define.amd) {
        // AMD (Asynchronous Module Definition - e.g., RequireJS)
        define(statsModuleFactory);
    } else {
        // Browser global
        globalScope.Stats = statsModuleFactory();
    }
})(this, function () {
    "use strict";

    const performanceSource = typeof self !== 'undefined' && self.performance || Date; // Prefer performance.now() but fallback to Date.now()

    class Panel {
        constructor(name, foregroundColor, backgroundColor) {
            this.name = name;
            this.foregroundColor = foregroundColor;
            this.backgroundColor = backgroundColor;

            this.minValue = Infinity;
            this.maxValue = 0;
            this.round = Math.round;
            // Ensure window exists for devicePixelRatio, otherwise default to 1 (for non-browser environments if Panel was ever used there)
            this.pixelRatio = this.round((typeof window !== 'undefined' && window.devicePixelRatio) || 1);


            // Panel dimensions and offsets, scaled by pixelRatio
            this.PR = this.pixelRatio; // Shorthand for pixelRatio
            this.WIDTH = 80 * this.PR;
            this.HEIGHT = 48 * this.PR;
            this.TEXT_X = 3 * this.PR;
            this.TEXT_Y = 2 * this.PR;
            this.GRAPH_X = 3 * this.PR;
            this.GRAPH_Y = 15 * this.PR;
            this.GRAPH_WIDTH = 74 * this.PR;
            this.GRAPH_HEIGHT = 30 * this.PR;

            // Check if document exists (for non-browser environments)
            if (typeof document === 'undefined') {
                this.dom = null; // or a mock element
                this.context = null;
                this.update = () => {}; // No-op update
                console.error("Stats.Panel: document is not available. Panel will not render.");
                return;
            }

            this.canvas = document.createElement("canvas");
            this.canvas.width = this.WIDTH;
            this.canvas.height = this.HEIGHT;
            this.canvas.style.cssText = `width:80px;height:48px;image-rendering:pixelated;image-rendering:crisp-edges;`; // Added image-rendering for sharper pixels

            this.context = this.canvas.getContext("2d");
            if (!this.context) {
                console.error("Stats.Panel: Failed to get 2D context");
                // Fallback to a simple div if canvas context is not available
                this.dom = document.createElement("div");
                this.update = () => {}; // No-op update
                return;
            }

            this.context.font = `bold ${9 * this.PR}px Helvetica,Arial,sans-serif`;
            this.context.textBaseline = "top";

            this.context.fillStyle = this.backgroundColor;
            this.context.fillRect(0, 0, this.WIDTH, this.HEIGHT);

            this.context.fillStyle = this.foregroundColor;
            this.context.fillText(this.name, this.TEXT_X, this.TEXT_Y);

            // Draw initial graph background
            this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT);
            this.context.fillStyle = this.backgroundColor;
            this.context.globalAlpha = 0.9;
            this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT);

            this.dom = this.canvas;
        }

        update(currentValue, rangeMaxValue) {
            if (!this.context) return; // Guard if context failed or not in browser

            this.minValue = Math.min(this.minValue, currentValue);
            this.maxValue = Math.max(this.maxValue, currentValue);

            // Clear the text area
            this.context.fillStyle = this.backgroundColor;
            this.context.globalAlpha = 1;
            this.context.fillRect(0, 0, this.WIDTH, this.GRAPH_Y); // Only clear the top part where text is

            // Draw the text
            this.context.fillStyle = this.foregroundColor;
            this.context.fillText(
                `${this.round(currentValue)} ${this.name} (${this.round(this.minValue)}-${this.round(this.maxValue)})`,
                this.TEXT_X,
                this.TEXT_Y
            );

            // Shift graph to the left
            this.context.drawImage(
                this.canvas,
                this.GRAPH_X + this.PR, // Source X (skip one pixel column)
                this.GRAPH_Y,           // Source Y
                this.GRAPH_WIDTH - this.PR, // Source Width (one less pixel column)
                this.GRAPH_HEIGHT,      // Source Height
                this.GRAPH_X,           // Destination X
                this.GRAPH_Y,           // Destination Y
                this.GRAPH_WIDTH - this.PR, // Destination Width
                this.GRAPH_HEIGHT       // Destination Height
            );

            // Draw the new data bar on the right
            // First, draw the full height bar in foreground color
            this.context.fillStyle = this.foregroundColor;
            this.context.fillRect(
                this.GRAPH_X + this.GRAPH_WIDTH - this.PR, // X position (last pixel column)
                this.GRAPH_Y,                              // Y position
                this.PR,                                   // Width (one pixel column)
                this.GRAPH_HEIGHT                          // Full height
            );

            // Then, draw the "empty" part of the bar in background color, scaled to value
            this.context.fillStyle = this.backgroundColor;
            this.context.globalAlpha = 0.9;
            this.context.fillRect(
                this.GRAPH_X + this.GRAPH_WIDTH - this.PR, // X position
                this.GRAPH_Y,                              // Y position
                this.PR,                                   // Width
                this.round((1 - (currentValue / rangeMaxValue)) * this.GRAPH_HEIGHT) // Height of the "empty" part
            );
        }

        // Optional: Add a destroy method to Panel if it ever holds resources
        // that aren't automatically cleaned up when its DOM element is removed.
        // For this Panel, removing its `this.dom` from the document is usually sufficient.
        destroy() {
            // If Panel had event listeners or complex objects, clean them here.
            // For this version, nullifying references can help the GC.
            if (this.canvas) this.canvas = null;
            if (this.context) this.context = null;
            if (this.dom) this.dom = null;
        }
    }

    class Stats {
        constructor() {
            this.REVISION = 17; // Incremented revision

            // Check if document is available (for non-browser environments)
            if (typeof document === 'undefined') {
                 console.error("Stats: document is not available. Stats will not be initialized.");
                 // Provide a mock DOM element or ensure methods fail gracefully
                 this.dom = null;
                 this.container = null;
                 // Mock methods to prevent errors if called
                 this.addPanel = () => {};
                 this.showPanel = () => {};
                 this.begin = () => {};
                 this.end = () => performanceSource.now();
                 this.update = () => {};
                 this.destroy = () => {};
                 return;
            }

            this.container = document.createElement("div");
            this.container.style.cssText =
                "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000;display:flex;flex-direction:column;align-items:flex-start;";

            this.beginTime = performanceSource.now();
            this.previousTime = this.beginTime;
            this.frames = 0;
            this.panels = []; // Store panels for easier cleanup

            this.fpsPanel = this.addPanel(new Panel("FPS", "#04ea04", "#002"));
            this.msPanel = this.addPanel(new Panel("MS", "#04ea04", "#002"));

            if (typeof self !== 'undefined' && self.performance && self.performance.memory) {
                this.memoryPanel = this.addPanel(new Panel("MB", "#04ea04", "#002"));
            } else {
                this.memoryPanel = null;
            }

            this.cpuCores = (typeof navigator !== 'undefined' && navigator.hardwareConcurrency) || 0; // Default to 0 if not supported
            if (this.cpuCores > 0) { // Only add CPU panel if core count is available
                this.cpuPanel = this.addPanel(new Panel(`CPU Threads (${this.cpuCores})`, "#04ea04", "#002"));
            } else {
                this.cpuPanel = null;
            }

            this.dom = this.container; // Expose the container
        }

        addPanel(panel) {
            if (this.container && panel && panel.dom) { // Ensure container and panel.dom exist
                this.container.appendChild(panel.dom);
                this.panels.push(panel); // Keep track of panels
            }
            return panel;
        }

        showPanel(/* id */) {
            // This original library allowed switching panels.
            // If you want to implement this, you'd manage visibility of panel.dom elements here.
            // For now, all panels added are shown.
        }

        begin() {
            this.beginTime = performanceSource.now();
        }

        end() {
            if (!this.container) return performanceSource.now(); // In case Stats was not initialized properly

            this.frames++;
            const time = performanceSource.now();

            if (this.msPanel) this.msPanel.update(time - this.beginTime, 200); // Max expected MS for graph scaling

            if (time >= this.previousTime + 1000) {
                if (this.fpsPanel) this.fpsPanel.update((this.frames * 1000) / (time - this.previousTime), 100); // Max expected FPS

                this.previousTime = time;
                this.frames = 0;

                if (this.memoryPanel && typeof self !== 'undefined' && self.performance && self.performance.memory) {
                    const memory = self.performance.memory;
                    this.memoryPanel.update(memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576);
                }

                if (this.cpuPanel && this.cpuCores > 0) {
                    this.cpuPanel.update(this.cpuCores, this.cpuCores);
                }
            }
            return time;
        }

        update() {
            this.beginTime = this.end();
        }

        destroy() {
            // Remove the main container from the DOM
            if (this.container && this.container.parentNode) {
                this.container.parentNode.removeChild(this.container);
            }

            // Call destroy on each panel (if they have specific cleanup)
            this.panels.forEach(panel => {
                if (panel && typeof panel.destroy === 'function') {
                    panel.destroy();
                }
            });

            // Nullify references to help garbage collection
            this.container = null;
            this.dom = null;
            this.panels = []; // Clear the array of panels

            this.fpsPanel = null;
            this.msPanel = null;
            this.memoryPanel = null;
            this.cpuPanel = null;
            // console.log("Stats instance destroyed");
        }

        setMode(/* mode */) {
            // Corresponds to showPanel; used to select which panel's data to display.
        }
    }

    // Attach Panel class to Stats for external extensibility if needed
    Stats.Panel = Panel;

    return Stats;
});